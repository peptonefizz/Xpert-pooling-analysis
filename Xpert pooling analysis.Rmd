---
title: "Xpert pooling"
author: "Tushar Garg"
date: "`r Sys.Date()`"
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo=F,message=F, warning=F)
suppressMessages(if (!require("pacman")) install.packages("pacman"))
pacman::p_load(tidyverse,rio,janitor,here,rbibutils,binGroup2,sessioninfo)
```

```{r session info}
# sessioninfo::session_info(pkgs = c("loaded", "attached")[1], to_file = here("Session info","session_info.txt"))
```

```{r import, include=F}
data <- import(here("Data","Xpert_pooling_data.xlsx"), which = "data")
combination <- import(here("Data","Xpert_pooling_data.xlsx"), which = "combination")
legend <- import(here("Data","Xpert_pooling_data.xlsx"), which = "legend") %>% clean_names()

master <- bind_cols(data,combination %>% select(-c(1:3))) %>% clean_names()
```

```{r binGroup2, include=F}
# matrix for specifying pool size in non-informative hierarchical testing in binGroup2
pool3 <- matrix(data = c(rep(1, 3), 1:3), nrow = 2, ncol = 3, byrow = TRUE)
pool4 <- matrix(data = c(rep(1, 4), 1:4), nrow = 2, ncol = 4, byrow = TRUE)

# function for calculating expected tests per individual
calculateExpTests <- function(p, pooln, Se, Sp) {
  pool_matrix <- get(pooln, envir = .GlobalEnv)
  output <- binGroup2::opChar1(algorithm = "D2", p = p, Se = Se, Sp = Sp, hier.config = pool_matrix, print.time = FALSE)
  return(ExpTests(output)$ExpTestsPerIndividual)
}
```

```{r main function, include=F}
# Define the main summarization function
summarizeAndCalculate <- function(df, poolsize, combination, Se, Sp) {
  comb_col <- rlang::sym(combination)
  summary_df <- df %>% 
    group_by(!!comb_col) %>% 
    summarise(
      tests_performed = sum(tests_performed),
      test_positive = sum(test_positive),
      positivity = test_positive / tests_performed,
    ) %>% as_tibble()
  
  summary_df <- summary_df %>%
    rowwise() %>%
    mutate(
      total_tests = case_when(
        !!comb_col == 0 ~ 0,
        !!comb_col == 1 ~ tests_performed,
        TRUE ~ ceiling(as.numeric(calculateExpTests(positivity, poolsize, Se, Sp)) * tests_performed)
      )
    ) %>% ungroup() %>%
    summarise(
      total_tests = sum(total_tests),
      missed_cases = sum(ifelse(!!comb_col == 0, test_positive, 0)) / sum(test_positive)
    )
  return(summary_df)
}
# Usage example
# Modify to comb_col <- rlang::ensym(combination)
# test <- summarizeAndCalculate(df, pool4, comb4)
```

```{r analysis}
# Defining values of sensitivity, specificity, pool size, combination and dataset identifiers
Se_values <- c(0.95, 0.99, 1) 
Sp_values <- c(0.95, 0.99, 1)
poolsize_values <- c("pool3", "pool4") 
combination_values <- colnames(combination %>% clean_names() %>% select(-c(1:3)))
identifier_values <- unique(master$identifier)

# Function to process a single combination
process_combination <- function(identifier, poolsize, combination, Se, Sp) {
  df_subset <- master %>% filter(identifier == !!identifier)
  combination <- as.character(combination)
  
  result <- summarizeAndCalculate(df_subset, poolsize, combination, Se, Sp)
  result <- cbind(identifier = identifier, poolsize = poolsize, combination = combination, Se = Se, Sp = Sp, result)
  return(result)
}

# Generate all combinations
results <- expand.grid(identifier = identifier_values, poolsize = poolsize_values, 
                       combination = combination_values, Se = Se_values, Sp = Sp_values, 
                       stringsAsFactors = FALSE)

# Apply the function to all combinations
output <- pmap(results, process_combination) %>% bind_rows()

output_summary <- left_join(output, legend, by="identifier")

output_summary %>% export(here("Output","Xpert_pooling_output.xlsx"))
```


```{r}
# tabulate or show visually
```

